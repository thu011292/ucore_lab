## lab7实验报告
### 2012011292 王子寒

注：本实验代码所在gitserver网址为 [github] [gitlab] 

#### 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
- 请给出内核级信号量的设计描述，并说其大致执行流流程。

    > 信号量最为重要的便是P和V操作，对应到ucore里便是__down和__up函数。  
    > 其中P操作首先关闭中断，然后通过信号量的value判断是否可以获得信号量。  
    > 若可以获得，则只要打开中断即可；若不可，则将当前进程加入等待队列，再打开中断，进行调度。  
    > 而当其被V操作唤醒时，只要将其从等待队列中删除即可。  
    > 而V操作则首先关闭中断，然后唤醒等待队列中的第一个进程（若无则value+1），最后打开中断。  
    > 通过以上P和V操作的联合，就能实现临界区的访问。

- 请给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

    > 为了实现用户态的信号量机制，需要添加多个SYSCALL系统调用。  
    > 比如sys_sem可返回一个信号量数据结构，sys_down表示P操作，sys_up表示V操作。  
    > 那么用户通过以上系统调用便可以实现用户态的信号量机制。

#### 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
- 请给出内核级条件变量的设计描述，并说其大致执行流流程。

    > ucore中条件变量的定义为condvar，其包含了三个成员变量：sem、count和owner。  
    > 信号量sem用于让发出wait_cv操作的等待某个条件C为真的进程睡眠，而让发出signal_cv操作的进程通过这个sem来唤醒睡眠的进程。  
    > count表示等在这个条件变量上的睡眠进程的个数。owner表示此条件变量的宿主是哪个管程。  
    > 与条件变量相关的最重要的两个函数wait_cv和signal_cv，在ucore中为cond_wait和cond_signal。  
    > cond_wait函数表示此进程等待某个条件C不为真，需要睡眠。然后需要唤醒因cond_signal而睡着了的进程或者是直接放弃管程。  
    > 而cond_signal则其实现主要是唤醒睡在当前信号量上的进程，并且自己沉睡在next信号量上，等待cond_wait唤醒。  
    > 基于以上cond_wait和cond_signal，就能实现临界区的互斥访问，并且在管程内部的进程能够积极放弃。

- 请给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

    > 相似的，也需要提供多个SYSCALL系统调用：  
    > sys_down和sys_up需要保留，再添加sys_waitcv和sys_signal用与条件变量，sys_mon用于申请管程。  
    > 用户通过以上一系列系统调用，便可以实现管程。

[github]:https://github.com/thu011292/ucore_lab.git
[gitlab]:http://south.cs.tsinghua.edu.cn/thu011292/ucore_lab.git
