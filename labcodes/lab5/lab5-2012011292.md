## lab5实验报告
### 2012011292 王子寒

注：本实验代码所在gitserver网址为 [github] [gitlab]

#### 练习1: 加载应用程序并执行
- 请简要说明你的设计实现过程。

    > 这一部分代码主要是重新设置用户进程的中断帧，使之能够让CPU跳转到用户特权级以及用户态空间，并且能跳转到用户进程的第一条指令。  
    > 其中cs、ds、es、ss只需设置成相应的用户段。  
    > 需要注意的是eip需要设置为elf的入口，以便能够跳转到用户程序的第一条指令。

- 描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

    > 首先清空用户态内存空间为加载用户执行代码做好准备。其中用到了exit_mmap、put_pgdir、mm_destroy一系列函数。  
    > 然后调用load_icode函数来进一步加载elf格式代码。  
    > 在load_icode中，首先创建并正确映射内存管理数据结构mm。然后根据应用程序执行码的起始位置来解析此ELF格式的执行程序。  
    > 接下来分配内存，设置用户栈，最后重新设置进程的中断帧，使得能够跳转到用户的第一条指令，并且能正确响应中断。

#### 练习2: 父进程复制自己的内存空间给子进程
- 请简要说明你的设计实现过程。

    > 这一部分代码内容较为简单，通过page2kva获取虚地址后就可通过memcpy进行复制了，之后通过page_insert建立好相应的页映射即可。

- 请简要说明如何设计实现”Copy on Write 机制“，给出概要设计。

    > 可以修改copy_range函数，将其改为仅复制需要的一个页，进而做到当需要多个进程对同一个资源进行写的时候，进行内容的复制。

#### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
- 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？

    > fork函数中，复制成功一个进程后调用wakeup_proc进行进程的唤醒。  
    > exit函数中，如果发现父进程处于等待状态，则将其唤醒以释放子进程；释放完毕后调用schedule进行进程的重新调度。  
    > wait函数中，循环等待直到发现处于僵尸状态的子进程，则释放其内存资源；若发现不为僵尸状态，则要重新通过schedule调度。  
    > exit函数中，设置当前进程状态为PROC_ZOMBIE，然后唤醒父进程进行资源的释放。

- 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。

    > 进程复制/创建(SYS_fork)---->进程执行（SYS_exec）
    > |                               |                  do_exit
    > |                       do_wait | schedule         =======>进程退出（SYS_exit）
    > |                               |  
    > |                           进程等待（SYS_wait）

[github]:https://github.com/thu011292/ucore_lab.git
[gitlab]:http://south.cs.tsinghua.edu.cn/thu011292/ucore_lab.git

