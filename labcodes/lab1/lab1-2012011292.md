## lab1实验报告
### 2012011292 王子寒

注：本实验代码所在gitserver网址为 [github] 

#### 练习1：理解通过make生成执行文件的过程。
- 操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)

    >  生成ucore.img的主要代码是```$(UCOREIMG): $(kernel) $(bootblock)```  
    >  为此需要kernel和bootblock模块，而这两者的生成代码为：
    >   ```
    $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
    $(kernel): $(KOBJS)
    >   ```

- 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

    >  从sign.c文件中可以看到，主引导扇区有512个字节。  
    >  并且第510个字节应为0x55，第511个字节应为0xAA。

#### 练习2：使用qemu执行并调试lab1中的软件。
- 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。

    > 在tools/gdbinit文件中增加```set architecture i8086```  
    > 然后通过make debug运行程序，再输入```si```即可单步调试BIOS

- 在初始化位置0x7c00设置实地址断点,测试断点正常。

    > 在tools/gdbinit文件中增加如下内容，即可做到断点调试：
    > ```
    set architecture i8086
    b *0x7c00
    x /2i $pc
    > ```

- 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。

    > 通过以上方法，得到的代码与源代码一致。
    
- 自己找一个bootloader或内核中的代码位置，设置断点并进行测试。

    > 方法完全等同于上述第二问，只需修改```0x7c00```为需要的断点即可。

#### 练习3：分析bootloader进入保护模式的过程。
- 请分析bootloader是如何完成从实模式进入保护模式的。

    > 首先进行初始化，将flag与段寄存器清零。  
    > 开启A20，使得地址线扩大至32位。  
    > 初始化GDT表。然后通过更改CR0寄存器进入保护模式。  
    > 最后设置段寄存器和堆栈寄存器，至此完全进入保护模式。

#### 练习4：分析bootloader加载ELF格式的OS的过程。
- bootloader如何读取硬盘扇区的？

    > 通过readsect和readseg函数来读取扇区。

- bootloader是如何加载ELF格式的OS？

    > 首先通过readseg函数读入ELF的头，再根据其成员变量e_magic判断其是否合法。  
    > 若合法，然后再根据ELF头中的信息将ELF中的数据装在如内存指定位置。

#### 练习5：实现函数调用堆栈跟踪函数
- 请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。

    > 最后一行输出如下：  
    > ```ebp:0x00007bf8 eip:0x00007d68 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8```  
    > 最后一行对应的应该是第一个使用函数堆栈的函数，即bootmain函数。  
    > 在bootloader中设置堆栈从0x7c00开始，使用"call bootmain"转入bootmain函数。  
    > call指令入栈，所以此时ebp为0x7bf8。

- 简要说明实现过程。

    > 此练习主要需要掌握的是函数堆栈的结构，主要是ebp和eip的含义。  
    > 只要理解了ebp作为指针，所指的内容为上一个函数的ebp的内容。
    > 而eip位于ebp+4的位置，指向的是返回函数的地址。  
    > 理解以上内容之后，只需要完成最简单的输出操作即可。

#### 练习6：完善中断初始化和处理
- 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？

    > 一个表项占8个字节。其中第6-7和0-1字节组成4字节的位移，2-3字节为段选择子。二者构成了中断处理代码的入口。

- 简要说明实现过程。

    > 初始化idt表，其关键在于理解SETGATE函数各个参数的意义。主要是段选择子和特权级的初始化。    
    > 时钟中断的实现则异常简单，参考答案后发现已经设好了一个变量ticks可供计数，不用再新设一个变量。

##### 实验感想：
> 本次实验其实在代码上并不是十分困难，其难点在于最初实验环境的建立，gdb和qemu的使用，以及实验框架的理解。
> 入门之后，结合实验指导书，代码的实验不是非常困难，但是对于代码的一些细节上的实验，主要在于一些已有的变量和函数的意义的理解
> 上，出现了一些问题，这只能通过仔仔细细地阅读实验源代码来彻底理解。最后我也相信之后的实验在代码的难度上会逐渐提升。

[github]:https://github.com/thu011292/ucore_lab.git
